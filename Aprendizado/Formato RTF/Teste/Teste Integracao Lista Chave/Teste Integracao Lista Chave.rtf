{\rtf1\ansi\ansicpg1252\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Arial;}}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\fs24\lang22 Vamos agora testar o endpoint (classe controller) que est\'e1 expondo o servi\'e7o de listagem de chaves pix. A classe controller faz uso de um Client gRPC do servi\'e7o listagem e por isso vamos mockar esse objeto (client gRPC) no nosso teste, pois n\'e3o queremos ficar dependente de um sistema que n\'e3o est\'e1 sob nosso controle.\par
O primeiro passo ser\'e1 criar a classe ListaChaveControllerTest anotada com @MicronautTest.\par
Como vamos utilizar o client gRPC (mesmo mockado) temos que ensinar como se cria um objeto desse tipo, pois o mesmo se utiliza de f\'e1brica (@Factory) para isso, ent\'e3o na classe ListaChaveControllerTest vamos criar a seguinte fun\'e7\'e3o:\par

\pard\box\brdrdash\brdrw0 \sa200\sl276\slmult1 @Singleton\line @Replaces(KeyManagerListaChavesGrpcServiceGrpc.KeyManagerListaChavesGrpcServiceBlockingStub::class)\line fun stubGrpc(): KeyManagerListaChavesGrpcServiceGrpc.KeyManagerListaChavesGrpcServiceBlockingStub \{\line     return Mockito.mock(KeyManagerListaChavesGrpcServiceGrpc.KeyManagerListaChavesGrpcServiceBlockingStub::class.\i java\i0 )\line\}\par

\pard\sa200\sl276\slmult1\par
Agora podemos criar a property que ser\'e1 o grpcCLient, pois agora o Micronaut j\'e1 sabera injetar o mesmo. Podemos tamb\'e9m ja criar o client do tipo Http, pois ser\'e1 esse o respons\'e1vel por lan\'e7ar a requsi\'e7\'e3o na classe ListaChaveController, classe/enpoint que queremos testar. Veja como ficou a classe de teste at\'e9 agora:\par
\par

\pard\box\brdrdash\brdrw0 \sa200\sl276\slmult1 @MicronautTest\line internal class ListaChaveControllerTest \{\line\line     @field:Inject\line     lateinit var grpcClient: KeyManagerListaChavesGrpcServiceGrpc.KeyManagerListaChavesGrpcServiceBlockingStub\line     \line     @field:Inject\line     @Client("/")\line     lateinit var httpClient: HttpClient\line     \line     // ESCREVA AS FUN\'c7\'d5ES @TEST AQUI!\line\line\line     @Singleton\line     @Replaces(KeyManagerListaChavesGrpcServiceGrpc.KeyManagerListaChavesGrpcServiceBlockingStub::class)\line     fun stubGrpc(): KeyManagerListaChavesGrpcServiceGrpc.KeyManagerListaChavesGrpcServiceBlockingStub \{\line         return Mockito.mock(KeyManagerListaChavesGrpcServiceGrpc.KeyManagerListaChavesGrpcServiceBlockingStub::class.\i java\i0 )\line     \}\line\}\par

\pard\sa200\sl276\slmult1\par
Nesta classe de teste vou tamb\'e9m criar a fun\'e7\'e3o retornaListaChavePixMessage, est\'e1 sempre ir\'e1 retornar uma lista de ChavePixMessage, esse tipo foi criado ao compilar o arquivo .proto, pois \'e9 uma classe l\'e1 do servi\'e7o gRPC. Eu vou precisar desse objeto para Mockar a resposta do gRPC. Veja como ficou essa fun\'e7\'e3o:\par
\par

\pard\box\brdrdash\brdrw0 \sa200\sl276\slmult1 fun retornaListaChavePixMessage(\line     instante: Instant,\line     pixIdEmail: String,\line     pixIdCelular: String\line ): List<ChavePixMessage> \{\line     val chaveEmail = ChavePixMessage.newBuilder()\line         .setCriadoEm(\line             Timestamp.newBuilder()\line                 .setSeconds(instante.\i epochSecond\i0 )\line                 .setNanos(instante.\i nano\i0 )\line                 .build()\line         )\line         .setTipoContaMessage(TipoContaMessage.\i CONTA_CORRENTE\i0 )\line         .setValor("yuri@gmail.com")\line         .setTipoChaveMessage(TipoChaveMessage.\i EMAIL\i0 )\line         .setPixId(pixIdEmail)\line         .build()\line\line     val chaveCelular = ChavePixMessage.newBuilder()\line         .setCriadoEm(\line             Timestamp.newBuilder()\line                 .setSeconds(instante.\i epochSecond\i0 )\line                 .setNanos(instante.\i nano\i0 )\line                 .build()\line         )\line         .setTipoContaMessage(TipoContaMessage.\i CONTA_CORRENTE\i0 )\line         .setValor("+5535988880000")\line         .setTipoChaveMessage(TipoChaveMessage.\i CELULAR\i0 )\line         .setPixId(pixIdCelular)\line         .build()\line\line     return \i listOf\i0 (chaveCelular, chaveEmail)\line\}\par

\pard\sa200\sl276\slmult1\par
Agora veja como ficou as fun\'e7\'f5es de teste:\par
\par

\pard\box\brdrdash\brdrw0 \sa200\sl276\slmult1 @Test\line fun `deve retornar uma lista de chave pix`() \{\line\line     //CENARIO\line     val clienteId = "5260263c-a3c1-4727-ae32-3bdb2538841b"\line     val requestHttp = HttpRequest.GET<Any>("/cliente/$\{clienteId\}/pix")\line\line     val instante = LocalDateTime.now().atZone(ZoneId.of("UTC")).toInstant()\line     val valorChaveEmail = "yuri@gmail.com"\line     val valorChaveCelular = "+5535988880000"\line\line     val requestGrpc = ListaChavesRequest.newBuilder()\line         .setIdentificadorCliente(clienteId)\line         .build()\line\line     val chavePixMessageList = retornaListaChavePixMessage(instante, valorChaveEmail, valorChaveCelular)\line     val responseGrp = ListaChavesResponse.newBuilder()\line         .setIdentificadorCliente(clienteId)\line         .addAllChaves(chavePixMessageList)\line         .build()\line\line     Mockito.`when`(grpcClient.listaChaves(requestGrpc)).thenReturn(responseGrp)\line\line     //A\'c7\'c3O\line     // val responseHttp = httpClient.toBlocking().exchange(requestHttp, Map::class.java ) ~ Essa linha funcionaria, mas eu n\'e3o teria acesso a lista de chave pix!\line     val responseHttp = httpClient.toBlocking()\line         .exchange(requestHttp, Argument.mapOf(Argument.\i STRING\i0 , Argument.listOf(ChavePixDto::class.\i java\i0 )))\line\line     //VERIFICA\'c7\'c3O\line     Assertions.assertEquals(HttpStatus.\i OK\i0 , responseHttp.\i status\i0 )\line     Assertions.assertEquals(2, responseHttp.body()!![clienteId]!!.size)\line     Assertions.assertEquals(valorChaveEmail, responseHttp.body()!![clienteId]!![1].chave)\line     Assertions.assertEquals(valorChaveCelular, responseHttp.body()!![clienteId]!![0].chave)\line\line\}\par
\line\line @Test\line fun `deve retornar mapa vazio ao passar clienteId sem chave`() \{\line\line     //CENARIO\line     val clienteId = UUID.randomUUID().toString()\line     val requestHttp = HttpRequest.GET<Any>("/cliente/$\{clienteId\}/pix")\line\line     val requestGrpc = ListaChavesRequest.newBuilder()\line         .setIdentificadorCliente(clienteId)\line         .build()\line\line     val responseGrp = ListaChavesResponse.newBuilder()\line         .setIdentificadorCliente(clienteId)\line         .build()\line\line     Mockito.`when`(grpcClient.listaChaves(requestGrpc)).thenReturn(responseGrp)\line\line     //A\'c7\'c3O\line     // val responseHttp = httpClient.toBlocking().exchange(requestHttp, Map::class.java ) ~ Essa linha funcionaria, mas eu n\'e3o teria acesso a lista de chave pix!\line     val responseHttp = httpClient.toBlocking()\line         .exchange(requestHttp, Argument.mapOf(Argument.\i STRING\i0 , Argument.listOf(ChavePixDto::class.\i java\i0 )))\line\line     //VERIFICA\'c7\'c3O\line     Assertions.assertEquals(HttpStatus.\i OK\i0 , responseHttp.\i status\i0 )\line     Assertions.assertTrue(responseHttp.body().isEmpty())\line\line\}\par
\line\line @Test\line fun `deve retornar badrequest ao informar um clienteId fora do padrao uudi`() \{\line\line     //CENARIO\line     val clienteId = "123"\line     val requestHttp = HttpRequest.GET<Any>("/cliente/$\{clienteId\}/pix")\line\line     val requestGrpc = ListaChavesRequest.newBuilder()\line         .setIdentificadorCliente(clienteId)\line         .build()\line\line     val responseGrp = ListaChavesResponse.newBuilder()\line         .setIdentificadorCliente(clienteId)\line         .build()\line\line     Mockito.`when`(grpcClient.listaChaves(requestGrpc)).thenReturn(responseGrp)\line\line     //A\'c7\'c3O\line     val erro = Assertions.assertThrows(HttpClientResponseException::class.\i java\i0 )\{\line         httpClient.toBlocking()\line             .exchange(requestHttp, Argument.mapOf(Argument.\i STRING\i0 , Argument.listOf(ChavePixDto::class.\i java\i0 )))\line     \}\line\line     //VERIFICA\'c7\'c3O\line     Assertions.assertEquals(HttpStatus.\i BAD_REQUEST\i0 , erro.\i status\i0 )\line\line\}\par

\pard\sa200\sl276\slmult1\par
Atente-se que houve uma pequena mudan\'e7a ao chamar o servi\'e7o HTTP, pois o servi\'e7o l\'e1 na classe controller est\'e1 retornando um Map<String, List<ChavePixDto>>, ent\'e3o o m\'e9todo para fazer a requisi\'e7\'e3o http ficou:\par
\par

\pard\box\brdrdash\brdrw0 \sa200\sl276\slmult1 val responseHttp = httpClient.toBlocking()\line     .exchange(requestHttp, Argument.mapOf(Argument.\i STRING\i0 , Argument.listOf(ChavePixDto::class.\i java\i0 )))\par

\pard\sa200\sl276\slmult1\par
Deste jeito tamb\'e9m funcionaria, mas eu n\'e3o teria acesso aos itens da lista para verificar seus valorres nos Assertions, eu poderia apenas verificar o status da response:\par

\pard\box\brdrdash\brdrw0 \sa200\sl276\slmult1 val responseHttp = httpClient.toBlocking().exchange(requestHttp, Map::class.java )\par

\pard\sa200\sl276\slmult1\par
}
 